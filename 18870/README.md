# [백준] 18870번: 좌표 압축

[문제 링크](https://www.acmicpc.net/problem/18870)

## 🎯 문제 분석

N개의 수로 이루어진 수열이 주어졌을 때, 각 숫자를 **"자신보다 작은 서로 다른 숫자의 개수"**로 변환(압축)하는 문제이다.

예를 들어, `[2, 4, -10, 4, -9]`가 입력되면,
* `-10`보다 작은 수는 0개
* `-9`보다 작은 수는 `-10` (1개)
* `2`보다 작은 수는 `-10`, `-9` (2개)
* `4`보다 작은 수는 `-10`, `-9`, `2` (3개)

따라서 결과는 `[2, 3, 0, 3, 1]`가 된다.

---

## ✨ 핵심 아이디어 및 알고리즘

이 문제는 **'좌표 압축(Coordinate Compression)'**이라는 대표적인 알고리즘 유형이다. 값의 범위가 매우 크지만(-10^9 ~ 10^9), 값의 개수(N)는 상대적으로 작을 때 유용하다.

문제의 본질은 각 숫자의 **'순위(Rank)'**를 찾는 것과 같다.

### 생각의 과정
1. **시간 복잡도 분석**: N이 최대 1,000,000이므로, O(N²) 알고리즘(이중 for문)은 시간 초과가 명백하다. **O(N log N) 이내**에 해결해야 함을 인지했다.
2. **문제 재정의**: "X보다 작은 서로 다른 수의 개수"는 "중복을 제거하고 오름차순으로 정렬했을 때, X의 인덱스"와 동일한 의미임을 파악했다.
3. **알고리즘 설계**:
    - 원본 배열의 순서를 유지하기 위해, 정렬 및 중복 제거를 위한 사본 배열을 만든다.
    - 사본 배열을 `sort`로 정렬하고, `unique`와 `erase`를 이용해 중복을 제거한다.
    - 원본 배열의 각 원소를 순회하며, 사본 배열에서 해당 원소의 위치(인덱스)를 `lower_bound` (이진 탐색)로 찾는다.



---

## 📚 배운 점 (Today I Learned)

### 1. 좌표 압축 (Coordinate Compression)
값의 실제 크기가 아닌, 값들 사이의 **상대적인 대소 관계**만이 중요할 때 사용하는 알고리즘임을 배웠다. 값들을 `0, 1, 2, ...` 와 같은 연속된 작은 정수로 매핑하여 메모리를 절약하고, 배열 인덱스로 활용하는 등 다양한 응용이 가능하다.

### 2. `sort` - `unique` - `erase` 패턴
C++ STL을 사용하여 벡터의 중복 원소를 제거하는 가장 표준적이고 효율적인 방법이다.
```cpp
// 1. 먼저 정렬하여 중복 원소들을 인접하게 만든다.
sort(vec.begin(), vec.end());

// 2. unique는 연속된 중복 원소를 벡터 뒤로 보내고, 그 쓰레기 값들의 시작 위치를 반환한다.
// 3. erase는 그 위치부터 벡터 끝까지의 원소들을 실제로 삭제한다.
vec.erase(unique(vec.begin(), vec.end()), vec.end());
```

### 3. `lower_bound`와 이터레이터 연산
`lower_bound`는 **정렬된 범위**에서 특정 값 이상이 처음 나타나는 위치의 **이터레이터(iterator)**를 O(log N) 시간 복잡도로 찾아준다.

반환된 이터레이터에서 컨테이너의 시작 이터레이터(`begin()`)를 빼는 연산을 통해, 해당 위치의 **인덱스**를 간단하게 계산할 수 있다. 이는 포인터 연산과 유사하며 매우 효율적이다.
```cpp
// sorted_unique 벡터에서 original[i]의 위치(인덱스) 찾기
auto it = lower_bound(sorted_unique.begin(), sorted_unique.end(), original[i]);
int index = it - sorted_unique.begin();
```

이 문제는 단순한 구현 능력을 넘어, 문제의 본질을 파악하고 적절한 알고리즘을 선택하여 적용하는 종합적인 사고력을 요구하는 좋은 문제였다.
