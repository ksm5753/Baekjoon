1. 제한 조건은 '제약'이 아닌, '가장 큰 힌트'다.
문제의 제한 조건을 통해 풀이 전략을 수립하는 법을 배웠다.
메모리 제한(8MB)을 보고 O(N) 공간 복잡도의 풀이가 불가능함을 가장 먼저 파악했고, 반면 입력값의 범위(1~10,000)가 매우 좁다는 점에서 값을 인덱스로 활용하는 계수 정렬(Counting Sort)의 실마리를 얻었다.
제한 조건은 제약사항이 아니라 문제 해결의 핵심 열쇠임을 깨달았다.

2. '만능 알고리즘'은 없다: 비교 정렬 vs. 비-비교 정렬
지금까지 퀵 정렬 기반의 std::sort만 사용해왔으나, 이 문제를 통해 처음으로 비-비교 정렬인 계수 정렬(Counting Sort) 을 학습하고 적용했다.
데이터의 분포 특성(값의 범위가 좁음)을 활용하면 $O(N \log N)$의 장벽을 넘어 $O(N+K)$라는 선형 시간 복잡도로 정렬이 가능함을 알게 되었다.

3. 데이터를 바라보는 관점의 전환: 값을 '저장'하는 것에서 '활용'하는 것으로
단순히 입력값을 리스트에 저장하는 방식에서 벗어나, '값 자체를 배열의 인덱스로' 사용하는 패러다임의 전환을 경험했다.
이를 통해 O(N)의 공간이 아닌 O(K) (K=값의 범위)의 공간만으로 문제를 해결할 수 있었다.
데이터 그 자체가 아닌, 데이터의 분포를 저장하는 아이디어를 배웠다.
