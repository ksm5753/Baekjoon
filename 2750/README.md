1. 문제 접근 방식
N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 가장 기본적인 문제이다.

처음에는 C++ STL에 내장된 sort 함수를 사용하여 간단하게 해결했다. <algorithm> 헤더를 포함하고, sort(vec.begin(), vec.end())를 호출하여 벡터를 정렬했다.

2. 시간 복잡도
std::sort 함수는 평균적으로 **O(N log N)**의 시간 복잡도를 가진다. (내부적으로는 퀵소트, 힙소트, 삽입 정렬이 결합된 하이브리드 정렬인 IntroSort를 사용한다고 알고 있다.)

문제의 N 최댓값이 1,000이므로 O(N log N)은 물론, O(N^2)의 시간 복잡도를 가진 정렬 알고리즘으로도 충분히 통과할 수 있는 범위이다.

3. 배운 점 및 고민한 점
다양한 정렬 알고리즘의 존재
이 문제를 계기로 기본적인 정렬 알고리즘들을 다시 한번 정리해볼 필요성을 느꼈다.

버블 정렬 (Bubble Sort): 인접한 두 원소를 비교하며 자리를 바꾸는 방식. 구현은 쉽지만 시간 복잡도가 O(N^2)으로 비효율적이다.

선택 정렬 (Selection Sort): 전체에서 최솟값을 찾아 맨 앞으로 보내는 과정을 반복하는 방식. 마찬가지로 O(N^2)이다.

삽입 정렬 (Insertion Sort): 이미 정렬된 부분에 새로운 원소를 적절한 위치에 삽입하는 방식. 평균적으로 O(N^2)이지만, 이미 거의 정렬된 상태에서는 매우 빠르게 동작하는 장점이 있다.

std::sort: 직접 구현할 필요 없이 가장 빠르고 안정적인 성능을 보여준다. 특별한 이유가 없다면 실무에서는 무조건 std::sort를 사용하는 것이 현명하다.

결론
단순히 문제를 푸는 것을 넘어, '왜 이 방법이 효율적인가?'를 항상 생각하는 습관을 들여야겠다. 다음에는 std::sort를 쓰지 않고, 직접 버블 정렬이나 선택 정렬을 구현해서 풀어보는 연습도 해야겠다.
